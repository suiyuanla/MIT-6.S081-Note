# First Lecture
## O/S DESIGN

## O/S Purprses

- Abstract
- Multiplex
- Isolation
- Sharing
- Security
- Performance
- Range of Uses

## O/S ORG 

| | ||
| :-----:|  :----: | :----: |:----:|
| User progress| vi | cc |sh|
| Kernel | File System | progresses |Access ctl
| Hardware | CPU | RAM |Disk

## API - Kernel
eg: 
	`app = open("out",1)`
	`write(fd,"hellp\n",6)`
	`pid = fork();`
	*look like function*
	*The kernel has privileges*
## Hard/Interesting
- Unforgiving
- Tensions  
	- Efficient - Abstact
	- Powerful - Simple API
	- Flexible - Secure
## This course
- Lectures
- Reading
- Labs
## XV6
- Risc-v
- QEMU in Linux
XV6 commands
1. read(fd,buf,sizeof(buf)); 
	- read return a num telling the read size 
	- sizeof(buf) tell the maxium size the read function can read in per
2. write(fd,buf,n)
	- n from the read() return
3. exit(num)
4. open()
	- open can open a file in pwd and the fd is the lowest num except the progress has used ...
5. fork()
	- fork cmd recalling kernel copy the current progress and the child has the same data with the parent ,the difference about them is only the fork function return num, the child return 0, the parent return a num >0
6. exec()
	- exec will completely replace the current progress 
	- if exec fail, it will return to the parent progress with num -1
	7. I/O Redirect 
		- it need fork and exec
		- fork the parent progress with the same fd
		- then change the fd and exec cmd 
		- it will change the I/O to the different direction